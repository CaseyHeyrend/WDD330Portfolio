<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Week 4 Notes</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" /> 
</head>

<body>
    <h1>JavaScript: Novice to Ninja, 2nd Edition</h1>
    <article>
        <h5><a href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/8">Chapter 8</a></h5>
        <h2>Forms</h2>
        <h3>Forms</h3>
        <p>Forms are made up of a <strong>form</strong> element that contains form controls such as input fields, select menus and buttons. 
           These input fields can be populated with information that is processed once the form has been submitted.</p>
        <h4>Form Controls</h4>
        <p>Some common types of form control are:</p>
        <ul>
            <li><strong>input</strong> fields, including text, passwords, check boxes, radio buttons, and file uploads</li>
            <li><strong>select</strong> menus for drop-down lists of options</li>
            <li><strong>textarea</strong> elements for longer text entry</li>
            <li><strong>button</strong> elements for submitting and resetting forms</li>
        </ul>
        <h3>Input Fields</h3>
        <p>Input fields are the most common types of form control, but there are several categories of input field as you’ll soon see.</p>
        <h4>Text Input Fields</h4>
        <p>The default type of input field is text, which is used for entering a short piece of text, such as a username.</p>
        <h4>Password Input Fields</h4>
        <p>input type='password' is used to enter passwords or secret information. 
           This works in the same way as an input field with type='text', except the characters are concealed as they are entered so they’re unable to be read on the screen.</p>
        <h4>Checkbox Input Fields</h4>
        <p>Check boxes are created using input fields with type='checkbox'. 
            They are used to select different options that can be checked (true) or left unchecked (false). 
            The user can select more than one checkbox from a list.</p>
        <h4>Radio Button Input Fields</h4>
        <p>Radio buttons are created using input fields with type='radio'. 
            Like checkboxes they allow users to check an option as true, but they provide an exclusive choice of options, so only one option can be selected.</p>
        <h4>Hidden Input Fields</h4>
        <p>Hidden fields can be created using input fields with type='hidden'. 
           These are not displayed by the browser, but have a 'value' attribute that can contain information that is submitted with the form. 
           They are often used to send information such as settings or information that the user has already provided. 
           Note that the information in these fields is in no way secret, as it’s visible in the HTML, so shouldn’t be used for sensitive data. 
           The value of a hidden input field can be changed using JavaScript in the same was as any other input field.</p>
        <h4>File Input Fields</h4>
        <p>A file input field can be created using input fields with type='file'. 
           These are used to upload files, and most browsers will provide a browse button or similar that lets users select a file from their file system.</p>
        <h4>Other Input Types</h4>
        <p>There are lots of new input types included in HTML5, such as number, tel and color. 
            As browsers start to support these, they will implement different user-interface elements depending on the input type. 
            So a number field might use a slider, whereas a date field will show a calendar. 
            They will also validate automatically, so an email input field will show an error message if there’s no valid email address.</p>
        <h4>Select Drop-Down List</h4>
        <p>Select drop-down lists can be used to select one or more options from a list of values. 
            The 'multiple' attribute is required if more than one option is to be selected. </p>
        <h4>Text Areas</h4>
        <p>A textarea element is used to enter long pieces of text over multiple lines such as a comment or blog post. 
           They work in much the same way as input fields. We access them using the 'name' attribute, and use the value property to see what text was entered.</p>
        <h4>Buttons</h4>
        <p>We’ve already used a button to submit a form, but there are different types of buttons. 
           The default type is 'submit', which is why we didn’t have to specify the type in the search example at the start of the chapter. 
           Another type we’ve already seen is 'reset', which will reset all the form fields to their initial settings.</p>
        <h3>Form Validation</h3>
        <p>Form validation is the process of checking whether a user has entered the information into a form correctly. 
            Examples of the types of validation that occur include ensuring that:</p>
        <ul>
            <li>A required field is completed</li>
            <li>An email address is valid</li>
            <li>A number is entered when numerical data is required</li>
            <li>A password is at least a minimum number of characters</li>
        </ul>
        <p>Validation can occur on the client side using JavaScript, and on the server side. 
            It is advisable to use both client-side and server-side validation. JavaScript should not be relied upon to validate any data before it’s saved to a database. 
            This is because it’s possible for a user to modify the JavaScript code and bypass the validation rules. </p>
        <h3>Disabling the Submit Button</h3>
        <p>Another useful technique that can aid usability is to disable the submit button if there are errors on the form. If the submit button is disabled then no action is taken when it’s clicked. 
            Most browsers will also display it in a lighter color to indicate that it cannot be clicked on. 
            This prevents users from submitting a form containing any errors.</p>
    </article>
      <article>
        <h5><a href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/12">Chapter 12</a></h5>
        <h2>Object-Oriented Programming in JavaScript</h2>
        <h3>Object-Oriented Programming</h3>
        <p>Object-oriented programming is often used to model representations of objects in the real world. 
           There are three main concepts in OOP: encapsulation, polymorphism and inheritance.</p>
        <h4>Encapsulation</h4>
        <p>The inner workings are kept hidden inside the object and only the essential functionalities are exposed to the end user, such as the 'on' button. 
           In OOP, this involves keeping all the programming logic inside an object and making methods available to implement the functionality, without the outside world needing to know how it’s done.</p>
        <h4>Polymorphism</h4>
        <p>The same process can be used for different objects. 
           In OOP, this means various objects can share the same method, but also have the ability to override shared methods with a more specific implementation.</p>
        <h4>Inheritance</h4>
        <p>Taking the features of one object then adding some new features. 
           In OOP, this means we can take an object that already exists and inherit all its properties and methods. 
           We can then improve on its functionality by adding new properties and methods.</p>
        <h4>Classes</h4>
        <p>Many object-oriented languages, such as Java and Ruby, are known as class-based languages. 
            This is because they use a class to define a blueprint for an object. 
            Objects are then created as an instance of that class, and inherit all the properties and methods of the class. I</p>
        <h3>Constructor Functions</h3>
        <p>The keyword this is used to represent the object that will be returned by the constructor function. 
           In the previous example, we use it to set the sides property to the argument that is provided to the constructor function.</p>
        <h4>The Constructor Property</h4>
        <p>All objects have a constructor property that returns the constructor function that created it.</p>
        <h3>Static Methods</h3>
        <p>The static keyword can be used in class declarations to create a static method. 
           These are sometimes called class methods in other programming languages. 
           A static method is called by the class directly rather than by instances of the class.</p>
           <h3>Prototypal Inheritance</h3>
           <p>JavaScript uses a prototypal inheritance model. 
              This means that every class has a prototype property that is shared by every instance of the class. 
              So any properties or methods of a class’s prototype can be accessed by every object instantiated by that class.</p>
           <h4>The Prototype Property</h4>
           <p>When creating a class, you would normally add any default properties and methods to the class declaration. 
               But what if you want to augment the class with extra methods and properties after it has been created? 
               It turns out that you can still do this using the prototype property of the class. </p>
           <h4>Finding Out the Prototype</h4>
           <p>There are a number of ways to find the prototype of an object. 
               One way is to go via the constructor function’s prototype property. 
               Another way is to use the Object.getPrototypeOf() method</p>
           <h3>Public and Private Methods</h3>
           <p>By default, an object’s methods are public in JavaScript. 
               Methods and properties are said to be public because they can be queried directly and changed by assignment. 
               The dynamic nature of the language means that an object’s properties and methods can be changed after it has been created.</p>
           <h3>Inheritance</h3>
           <p>The examples we’ve seen so far have all demonstrated inheritance by inheriting properties and methods from the prototype. 
              But the prototype is just another object, so it also has its own prototype, which in turn has its own prototype... and so on, creating a chain of inheritance.</p>
           <h3>The Object Constructor</h3>
           <p>When an object calls a method, the JavaScript engine will check to see if the object has that method. 
              If it doesn’t, it will check if the object’s prototype has the method. If not, it will check whether the prototype’s prototype has it. 
              This continues all the way up the prototype chain, until it reaches the prototype of the Object() constructor function, from which all objects in JavaScript inherit.</p>
           <h4>Enumerable Properties</h4>
           <p>Properties of objects in JavaScript are said to be enumerable or non-enumerable. 
              If they aren't enumerable, this means they will not show up when a for-in loop is used to loop through an object’s properties and methods.</p>
           <h4>Inheritance Using extends</h4>
           <p>A class can inherit from another class using the extends keyword in a class declaration.</p>
           <br>
           <h3>Polymorphism</h3>
           <p>The concept of polymorphism means that different objects can have the same method, but implement it in different ways. 
              The Object.prototype object has a toString() method that is shared by all objects. This means every object created in JavaScript will have a toString() method. Polymorphism means that objects are able to override this method with a more specific implementation. 
              So although every object has a toString() method, the way it’s implemented can vary between different objects.</p>
           <h3>Adding Methods to Built-in Objects</h3>
           <p>It is possible to add more methods to the prototype of JavaScript’s built-in objects — such as Number, String, and Array — to add more functionality. 
              This practice is known as monkey-patching, but it’s mostly frowned upon in the JavaScript community, despite it being an incredibly powerful technique (The Ruby programming community, on the other hand, generally embrace monkey-patching, so it is quite common in Ruby code examples.) .</p>
           <h3>Property Attributes and Descriptors</h3>
           <p>We’ve already seen that all objects are collections of key-value paired properties. It turns out that each property has a number of attributes that provide information about the property. 
               These attributes are stored in a property descriptor, which is an object that contains values of each attribute.</p>
           <p>All object properties have the following attributes stored in a property descriptor:</p>
           <ul>
               <li>value ― This is the value of the property and is undefined by default</li>
               <li>writable ― This boolean value shows whether a property can be changed or not, and is false by default</li>
               <li>enumerable ― this boolean value shows whether a property will show up when the object is displayed in a for in loop, and is false by default</li>
               <li>configurable ― this boolean value shows whether you can delete a property or change any of its attributes, and is false by default.</li>
           </ul>
           <h4>Getting and Setting Property Descriptors</h4>
           <p>The Object() constructor function has a number of methods for getting and defining property descriptors. 
               We can see these values using the Object.getOwnPropertyDescriptor() method.</p>
           <h4>Getters and Setters</h4>
           <p>An object property descriptor can have get() and set() methods instead of a value attribute. 
              All objects must have one or the other, they can't have both. 
              The get() and set() methods can be used to control how a property is set using assignment and the value that is returned when a property is queried.</p>
           <h3>Creating Objects from Other Objects</h3>
           <p>It’s possible to avoid using classes altogether, and create new objects based on another object that acts as a 'blueprint' or prototype instead.
              The Object() constructor function has a method called create that can be used to create a new object that is an exact copy of the object that is provided as an argument. 
              The object that is provided as the argument acts as the prototype for the new object.</p>
           <h3>Mixins</h3>
           <p>A mixin is a way of adding properties and methods of some objects to another object without using inheritance. 
              It allows more complex objects to be created by ‘mixing’ basic objects together.</p>
            <h4>Using Mixins to Create a copy() Function</h4>
        <p>Another use of the mixin() function is to create a copy() method that can be used to make an exact, deep copy of an object</p>
        <h3>Chaining Functions</h3>
        <p>If a method returns this, its methods can be chained together to form a sequence of method calls that are called one after the other.</p>
        <h3>Binding this</h3>
        <p>We saw earlier that the value of this points to the object calling a method. 
            It allows us to create generalized methods that refer to properties specific to a particular object. 
            Be aware of a certain problem when a function is nested inside another function, which can often happen when using methods in objects, especially ones that accept callback functions. 
            The problem is that the value of this loses its scope, and points to the global object inside a nested function</p>
        <h4>Use that = this</h4>
        <p>A common solution is to set the variable that to equal this before the nested function, and refer to that in the nested function instead of this. </p>
        <h4>Use bind(this)</h4>
        <p>The bind() method is a method for all functions and is used to set the value of this in the function. 
           If this is provided as an argument to bind() while it’s still in scope, any reference to this inside the nested function will be bound to the object calling the original method.</p>
        <h4>Use for-of Instead Of forEach()</h4>
        <h4>Use Arrow Functions</h4>
        <p>Arrow functions were introduced in ES6, and one of the advantages of using them is that they don't have their own this context, so this remains bound to the original object making the function call.</p>
        <br>
        <h3>Borrowing Methods from Prototypes</h3>
        <p>It’s possible to borrow methods from objects without having to inherit all their properties and methods. 
           This is done by making a reference to the function that you want to borrow (that is, without parentheses so that it isn’t invoked).</p>
        <h4>Borrowing Array Methods</h4>
        <p>One of the most common uses of borrowing methods was to borrow methods from arrays in ES5. 
           There are many array-like objects in JavaScript, such as the arguments object that’s available in functions, and the node lists that many of the DOM methods return.</p>
        <h3>Composition Over Inheritance</h3>
        <p>There are a number of benefits to object-oriented programming, but there are also some problems that come with inheritance.</p>
        <p>Composition over inheritance is a design pattern where objects are composed from 'building-block' objects, rather than inheriting all their properties and methods from a parent class.</p>
    </article>
      <article>
        <h5><a href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/15">Chapter 15</a></h5>
    </article>
</body>
</html>
